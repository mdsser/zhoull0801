<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>励志总结</title>
      <link href="/2021/06/16/%E5%8A%B1%E5%BF%97%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/16/%E5%8A%B1%E5%BF%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Those time when you get up early and you work hard.</p><p>那些你很早爬起来努力的时光</p><p>Those times when you stay up late and you work hard.</p><p>那些你熬夜刻苦训练的日子</p><p>Those times when you don’t feel like working, you’re too tired and you don’t want to push yourself, but you do it anyway，that is actually the dream.</p><p>那些你觉得太累了不想继续努力，但仍然咬牙坚持的时光</p><p>It’s not the destination, it’s the journey.</p><p>但是，真正的梦想不是到达终点，而是享受旅途</p><p>And if you guys can understand that</p><p>如果你们能理解这个道理</p><p>Then if you will see happen</p><p>你会发现，在努力的过程中</p><p>Is that you won’t accomplish your dreams you dreams won’t come true </p><p>你的梦想或许会实现，也或许不会</p><p>something greater will</p><p>但总会有一些更伟大的事情会随之而来。</p>]]></content>
      
      
      <categories>
          
          <category> 励志语录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本100例(上)</title>
      <link href="/2021/06/15/SHELL%E8%84%9A%E6%9C%AC100%E4%BE%8B-%E4%B8%8A/"/>
      <url>/2021/06/15/SHELL%E8%84%9A%E6%9C%AC100%E4%BE%8B-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h4 id="1、编写hello-world脚本"><a href="#1、编写hello-world脚本" class="headerlink" title="1、编写hello world脚本"></a><strong>1、编写hello world脚本</strong></h4><blockquote><p>#! /bin/bash</p><p>echo “hello world”</p></blockquote><h4 id="2、通过位置变量创建Linux系统账户及密码"><a href="#2、通过位置变量创建Linux系统账户及密码" class="headerlink" title="2、通过位置变量创建Linux系统账户及密码"></a><strong>2、通过位置变量创建Linux系统账户及密码</strong></h4><blockquote><p>#! /bin/bash</p><p>#$1 是执行脚本的第一个参数，$2是执行脚本的第二个参数</p><p>useradd “$1”</p><p>echo “$2” | passwd –stdin “$2”</p></blockquote><h4 id="3、每周5使用tar命令备份-var-log下的所有日志文件"><a href="#3、每周5使用tar命令备份-var-log下的所有日志文件" class="headerlink" title="3、每周5使用tar命令备份/var/log下的所有日志文件"></a><strong>3、每周5使用tar命令备份/var/log下的所有日志文件</strong></h4><blockquote><p>#! /bin/bash</p><p>#编写备份脚本，备份后的文件名包括日期标签，防止后面的备份将前面的备份数据覆盖</p><p>#注意date命令需要使用反引号括起来，反引号在键盘<tab>键上面 </p><p>tar  -czf  log-<code>date +%Y%m%d</code>.tar.gz  /var/log</p><p>#crontab -e                        #编写计划任务，执行备份脚本</p><p>00 03 * * 5     /root/logbak.sh</p></blockquote><h4 id="4、一键部署LNMP（RPM包版本）"><a href="#4、一键部署LNMP（RPM包版本）" class="headerlink" title="4、一键部署LNMP（RPM包版本）"></a><strong>4、一键部署LNMP（RPM包版本）</strong></h4><blockquote><p>#! /bin/bash</p><p>#使用yum安装部署LNMP，需要提前配置好yum源，否则该脚本会失败</p><p>#本脚本使用于centos7.2或RHEL7.2 </p><p>yum -y install httpd</p><p>yum -y install mariadb mariadb-devel mariadb-server</p><p>yum -y install php*</p><p>systemctl start httpd mariadb </p><p>systemctl enable httpd mariadb</p></blockquote><h4 id="5、实时监控本机内存和硬盘剩余空间，剩余内存小于500M、根分区剩余空间小于1000M时，发送报警邮件给root管理员"><a href="#5、实时监控本机内存和硬盘剩余空间，剩余内存小于500M、根分区剩余空间小于1000M时，发送报警邮件给root管理员" class="headerlink" title="5、实时监控本机内存和硬盘剩余空间，剩余内存小于500M、根分区剩余空间小于1000M时，发送报警邮件给root管理员"></a><strong>5、实时监控本机内存和硬盘剩余空间，剩余内存小于500M、根分区剩余空间小于1000M时，发送报警邮件给root管理员</strong></h4><blockquote><p>#! /bin/bash</p><p>#提取根分区剩余空间</p><p>disk_size=$(df / |awk ‘///{print $4}’)</p><p>#提取内存剩余空间</p><p>men_size=$(free |awk ‘/Mem/{print $4}’)</p><p>while :</p><p>do</p><p>#注意内存和磁盘提取的空间大小都是以kb为单位</p><p>if [ $disk_size -le 512000 -a $men_size -le 1024000 ];then mail -s Warning root &lt;&lt;EOF</p><p>Insufficient resources, 资源不足</p><p>EOF</p><p>fi</p><p>done</p></blockquote><h4 id="6、脚本生成一个100以内的随机数，提示用户猜数字，根据用户的输入，提示用户猜对了，猜小了或猜大了，直至用户猜对脚本结束。"><a href="#6、脚本生成一个100以内的随机数，提示用户猜数字，根据用户的输入，提示用户猜对了，猜小了或猜大了，直至用户猜对脚本结束。" class="headerlink" title="6、脚本生成一个100以内的随机数，提示用户猜数字，根据用户的输入，提示用户猜对了，猜小了或猜大了，直至用户猜对脚本结束。"></a><strong>6、脚本生成一个100以内的随机数，提示用户猜数字，根据用户的输入，提示用户猜对了，猜小了或猜大了，直至用户猜对脚本结束。</strong></h4><blockquote><p>#! /bin/bash</p><p>#RANDOM为系统自带的系统变量，值为0-32767的随机数</p><p>#使用取余算法将随机数变为1-100的随机数</p><p>num=$[RANDOM%100+1]</p><p>#使用read提示用户猜数字</p><p>#使用if判断用户猜数字的大小关系：-eq(等于)，-ne(不等于)，-gt(大鱼)，-ge(大于等于)，-lt(小于)，-le(小于或等于)</p><p>while :<br>do<br>        read -p “计算机生成了一个1-100的随机数，你猜:” a<br>        if [  $a  -eq  $num  ];then<br>                echo   “恭喜，猜对了”<br>                exit<br>        elif [  $a  -gt  $num  ];then<br>                echo  “Oops,猜大了”<br>        else<br>                echo  “Oops,猜小了”<br>        fi<br>done</p></blockquote><p>7、检测本机当前用户是否为超级管理员，如果是管理员，则使用yum安装vsftpd，如果不是，则提示您非管理员（使用字串对比版本）</p><blockquote><p>#! /bin/bash</p><p>if [     $USER    ==   “root”    ];then</p><p>​               yum  -y  install   vsftpd</p><p>else</p><p>​                echo  “您不是管理员，没有权限安装软件”</p><p>fi</p></blockquote><p>8、检测本机当前用户是否为超级管理员，如果是管理员，则使用yum安装vsftpd，如果不是，则提示您非管理员（使用UID数字对比版本）</p><blockquote><p>#! /bin/bash</p><p>if [     $UID    -eq    0    ];then</p><p>​               yum  -y  install   vsftpd</p><p>else</p><p>​                echo  “您不是管理员，没有权限安装软件”</p><p>fi</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Shell脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 原理解析</title>
      <link href="/2021/06/15/HTTPS-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/06/15/HTTPS-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>HTTPS是在HTTP和TCP之间建立了一个安全层，HTTP与TCP通信的时候，必须先经过一个安全层，对数据包进行加密，然后将加密后的数据包传送给TCP，相应的TCP必&lt;须将数据包进行解密，才能传送给上面的HTTP。</p><h3 id="一、基本概念及理解"><a href="#一、基本概念及理解" class="headerlink" title="一、基本概念及理解"></a><strong>一、基本概念及理解</strong></h3><p><font color='green'>TLS/SSL的功能实现主要依赖于三类基本算法</font></p><p>散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p><p>非对称加密是实现身份认证和密钥协商；</p><p>对称加密是对信息进行加密；</p><p><img src="C:\Users\86132\AppData\Roaming\Typora\typora-user-images\image-20210615094338143.png" alt="image-20210615094338143"></p><p><font color='green'>SSL和TLS的区别？</font></p><p>SSL和TLS都是加密协议，有网络请求的地方就可以使用这两种协议在传输层进行加密，确保数据传输的安全，**<code>SSL是TLS的前身</code>**，网景在1995年发布了直接发布了SSL 2.0版本，1.0版本没有对外发布。由于漏洞的原因，版本2.0也只是昙花一现，网景在1996年就发布了SSL3.0。随后在1999年的时候，基于SSL3.0版本，网景发布了TLS1.0版本(虽然TLS1.0在SSL3.0基础上的改动不太大，但是这些改动都是非常重要的)。</p><p>**<code>我们现在应该使用TLS协议</code>**，因为在2011年和2015年的时候SSL2.0和SSL3.0就已经分别被弃用了，而且由于漏洞的缘故，如果你的服务器配置了SSL的协议，还得手动将他们禁用掉。所以我们只给服务器配置TLS协议就好了，有的服务对TLS版本有要求，你可以在SSL Server Test查看服务器的证书及协议等配置。</p><p>SSL Server Test：</p><p><a href="https://globalsign.ssllabs.com/">https://globalsign.ssllabs.com/</a></p><p>现在TLS主流版本是1.2。</p>]]></content>
      
      
      <categories>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语短语</title>
      <link href="/2021/06/13/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/"/>
      <url>/2021/06/13/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<div align = "center">英语短语</div><hr><p>1、as far as                    至于,直到,远到</p><p>2、go on doing sth.      继续做同一件事    go on to do sth.       接下来做另一件事</p><p>3、take in吸收    take on承担    take up   拿起 take off        起飞,脱开,离开</p><p>4、might as well        不妨,倒不如,还是….的好</p><p>5、no sooner than    一……就……</p><p>6、make oneself at home    别拘束,随便,就当在家一样</p><p>7、make up     编造,化装</p><p>8、set aside     留出,不顾 set out 出发,开始 set up 建立,开业 set in  开始,到来</p><p>​      </p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 短语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2021/06/11/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2021/06/11/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL索引</strong></p><p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。</p><p>为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引。</p><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：<strong>索引是数据结构。</strong></p><hr><p><strong>MySQL索引原理</strong></p><p>==索引目的==</p><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p><p>如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p><p>咱们去图书馆借书也是一样，如果你要借某一本书，一定是先找到对应的分类科目，再找到对应的编号，这是生活中活生生的例子，通用索引，可以加快查询速度，快速定位。</p><hr><p>==索引原理==</p><p>所有索引原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between)、模糊查询(like)、并集查询(or)、多值匹配（in【in本质上属于多个or】）等等。</p><hr><p>==索引结构==</p><p>任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么</p><p>其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？</p><p>就这样，b+树应运而生。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的压缩与解压缩命令</title>
      <link href="/2021/06/10/Linux%E4%B8%8B%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/06/10/Linux%E4%B8%8B%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr><hr><p><strong>gzip命令</strong></p><p>gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。</p><p>gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>选项：</strong></p><p>-a：使用ASCII文字模式；</p><p>-d：解开压缩文件；</p><p>-f：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</p><p>-h：在线帮助；</p><p>-l：列出压缩文件的相关信息；</p><p>-L：显示版本与版权信息；</p><p>-n：压缩文件时，不保存原来的文件名称及时间戳记；</p><p>-N：压缩文件时，保存原来的文件名称及时间戳记；</p><p>-q：不显示警告信息；</p><p>-r：递归处理，将指定目录下的所有文件及子目录一并处理；</p><p>-S或&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；</p><p>-t：测试压缩文件是否正确无误；</p><p>-v：显示指令执行过程；</p><p>-V：显示版本信息；</p><p>-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；</p><p>–best：此参数的效果和指定“-9”参数相同；</p><p>–fast：此参数的效果和指定“-1”参数相同。</p><hr><p>实例</p><p>\1. 把test6目录下的每个文件压缩成.gz文件</p><p>gzip *</p><p>\2. 把上例中每个压缩的文件解压，并列出详细的信息</p><p>gzip -dv *</p><p>\3. 详细显示例1中每个压缩的文件的信息，并不解压</p><p>gzip -l *</p><p>4.压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz</p><p>gzip -r log.tar</p><p>\5. 递归的压缩目录</p><p>gzip -rv test6</p><p>这样，所有test下面的文件都变成了*.gz，目录依然存在只是目录里面的文件相应变成了*.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。</p><p>\6. 递归地解压目录</p><p>gzip -dr test6</p><hr><p><strong>gunzip命令</strong></p><p>gunzip命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被<a href="http://man.linuxde.net/gzip">gzip</a>压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。</p><p><strong>选项：</strong></p><p>-a：使用ASCII文字模式；</p><p>-c：把解压后的文件输出到标准输出设备；</p><p>-f：强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接；</p><p>-h：在线帮助；</p><p>-l：列出压缩文件的相关信息；</p><p>-L：显示版本与版权信息；</p><p>-n：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理；</p><p>-N：解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上；</p><p>-q：不显示警告信息；</p><p>-r：递归处理，将指定目录下的所有文件及子目录一并处理；</p><p>-S或&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；</p><p>-t：测试压缩文件是否正确无误；</p><p>-v：显示指令执行过程；</p><p>-V：显示版本信息；</p><hr><p>实例</p><p>\1. 首先将/etc目录下的所有文件以及子目录进行压缩，备份压缩包etc.<a href="http://man.linuxde.net/zip">zip</a>到/opt目录，然后对etc.zip文件进行gzip压缩，设置gzip的压缩级别为9。</p><p>zip –r /opt/etc.zip /etc</p><p>gzip -9v /opt/etc.zip</p><p>\2. 查看上述etc.zip.gz文件的压缩信息。</p><p>gzip -l /opt/etc.zip.gz</p><p>compressed    uncompressed ratio uncompressed_name</p><p>11938745      12767265  6.5% /opt/etc.zip</p><p>\3. 解压上述etc.zip.gz文件到当前目录。</p><p>[root@mylinux ~]#gzip –d /opt/etc.zip.gz</p><p>或者执行</p><p>[root@mylinux ~]#gunzip /opt/etc.zip.gz</p><p>通过上面的示例可以知道gzip –d等价于gunzip命令。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="/2021/06/10/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2021/06/10/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><h3 id="1、MySQL主从复制概述"><a href="#1、MySQL主从复制概述" class="headerlink" title="1、MySQL主从复制概述"></a><strong>1、MySQL主从复制概述</strong></h3><blockquote><p>MySQL作为世界上使用最为广泛的数据库之一，免费是其原因之一；但不可忽略的是它本身的功能的确很强大。随着技术的发展，在实际的生产环境中，由单台MySQL数据库服务器不能满足实际的需求。此时数据库集群就很好的解决了这个问题了。采用MySQL分布式集群，能够搭建一个高并发、负载均衡的集群服务器。在此之前我们必须要保证每台MySQL服务器里的数据同步。</p></blockquote><h4 id="1-1-MySQL主从复制概念"><a href="#1-1-MySQL主从复制概念" class="headerlink" title="1.1 MySQL主从复制概念"></a><strong>1.1 MySQL主从复制概念</strong></h4><blockquote><p>​       MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p></blockquote><h4 id="1-2-MySQL主从复制原理"><a href="#1-2-MySQL主从复制原理" class="headerlink" title="1.2  MySQL主从复制原理"></a><strong>1.2  MySQL主从复制原理</strong></h4><blockquote><p>​        MySQL服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。</p><p>​        MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个（I/Othread，SQL thread）运行在从节点，如下图所示：</p></blockquote><p><strong>主从复制架构图：</strong></p><p><img src="https://pic1.zhimg.com/v2-1b0c3f31bd398c39b9e0930059b0ca24_b.jpg" alt="img"></p><blockquote><p>主节点 binary log dump 线程</p></blockquote><p>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p><blockquote><p>从节点I/O线程</p></blockquote><p>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。</p><blockquote><p>从节点SQL线程</p></blockquote><p>SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p><p>对于每一个主从连接，都需要三个进程来完成。当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。比如，如果从节点没有运行，此时I/O进程可以很快从主节点获取更新，尽管SQL进程还没有执行。如果在SQL进程执行之前从节点服务停止，至少I/O进程已经从主节点拉取到了最新的变更并且保存在本地relay日志中，当服务再次起来之后，就可以完成数据的同步。</p><p>要实施复制，首先必须打开Master 端的binary log（bin-log）功能，否则无法实现。<br>因为整个复制过程实际上就是Slave 从Master 端获取该日志然后再在自己身上完全顺序的执行日志中所记录的各种操作。如下图所示：</p><p><img src="https://pic4.zhimg.com/v2-17a1d089c3266a59b5d00d7bd055bed7_b.jpg" alt="img"></p><h3 id="2、-主从复制的分类"><a href="#2、-主从复制的分类" class="headerlink" title="2、 主从复制的分类"></a><strong>2、 主从复制的分类</strong></h3><p>MySQL主从复制按照binlog的三种日志格式进行划分：</p><h4 id="1-1基于SQL语句的复制-statement-based-replication-SBR-："><a href="#1-1基于SQL语句的复制-statement-based-replication-SBR-：" class="headerlink" title="1.1基于SQL语句的复制(statement-based replication, SBR)："></a><strong>1.1基于SQL语句的复制(statement-based replication, SBR)：</strong></h4><p>优点：</p><ul><li>历史悠久，技术成熟。</li><li>产生的binlog文件较小，比较节省空间。</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况；binlog可以用于实时的还原，而不仅仅用于复制。</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高。</li></ul><p>缺点：</p><ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候。</li><li>调用具有不确定因素的 UDF（用户自定义函数）时复制也可能出问题。</li><li>INSERT … SELECT会产生更多的行级锁</li><li>使用以下函数的语句也无法被复制：<ul><li>LOAD_FILE()</li><li>UUID()</li><li>USER()</li><li>FOUND_ROWS()</li><li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</li></ul></li></ul><h4 id="2-2基于行的复制-row-based-replication-RBR-："><a href="#2-2基于行的复制-row-based-replication-RBR-：" class="headerlink" title="2.2基于行的复制(row-based replication, RBR)："></a><strong>2.2基于行的复制(row-based replication, RBR)：</strong></h4><p>优点：</p><ul><li>任何情况都可以被复制，这对复制来说是最安全可靠的。</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多。</li><li>从服务器上采用多线程来执行复制成为可能。</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少。</li><li>复制以下几种语句时的行锁更少：<ul><li>INSERT … SELECT</li><li>包含 AUTO_INCREMENT 字段的 INSERT</li><li>没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li></ul></li></ul><p>缺点：</p><ul><li>binlog 文件太大</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li><li>UDF 产生的大 BLOB值（较大的二进制对象）会导致复制变慢</li><li>无法从 binlog 中看到都复制了写什么语句，无法进行审计。</li></ul><p>3、混合模式复制(mixed-based replication, MBR)：是上面两种方式的折中。</p><p>以上三种模式对应binlog的三种格式：STATEMENT，ROW，MIXED。</p><h3 id="3、-主从复制的方式"><a href="#3、-主从复制的方式" class="headerlink" title="3、 主从复制的方式"></a><strong>3、 主从复制的方式</strong></h3><p><strong>异步复制：</strong>（默认的复制策略是此方式）</p><p>​        主服务器执行Commit提交事务操作并写入BINLOG日志后即可成功返回客户端，无需等待BINLOG日志传送给从服务器，这样主服务器和从服务器的数据之间难免会存在一定的延迟。</p><p><img src="https://pic1.zhimg.com/v2-c15bfffe3e398eafc7e0ffdaeebfcaac_b.jpg" alt="img"></p><p><strong>半同步复制：</strong></p><p>​        主服务器处理事务过程中，提交完事务后，必须等至少一个从服务器将收到的binlog写入relay log并返回ack确认消息才能继续执行处理用户的事务。</p><p><img src="https://pic2.zhimg.com/v2-d9ac9c5493d1d772f5bf57ede089f0d5_b.jpg" alt="img"></p><p>半同步模式不是mysql内置的，从mysql 5.5开始集成，需要master 和slave 安装插件开启半同步模式。</p><p><strong>增强半同步复制：</strong></p><p>为了保证主服务器上的每一个BINLOG事务都能够被可靠地复制到从服务器上，主服务器写数据后并不提交事务而是先将操作写入到BINLOG，然后等待至少一个从服务器接收到BINLOG事务并成功写入中继日志后，主服务器才返回Commit操作成功给客户端。</p><h3 id="4、-MySQL主从复制的好处"><a href="#4、-MySQL主从复制的好处" class="headerlink" title="4、 MySQL主从复制的好处"></a><strong>4、 MySQL主从复制的好处</strong></h3><ul><li>实时备份，提高数据安全性，同时用于故障切换，避免影响业务。</li><li>读写分离（mysql-proxy），将读请求交给从服务器，实现负载分担。</li><li>数据库性能提高，通过增加从数据库组建集群，提高总性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP</title>
      <link href="/2021/06/10/ARP/"/>
      <url>/2021/06/10/ARP/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是ARP？ARP作用和使用场景</strong></p><hr><p><strong>一、什么是ARP</strong><br>ARP是地址转换协议（Address Resolution Protocol）的英文缩写，它是一个链路层协议，工作在OSI 模型的第二层，在本层和硬件接口间进行联系，同时对上层（网络层）提供服务。我们知道二层的以太网交换设备并不能识别32位的IP地址，它们是以48位以太网地址（就是我们常说的MAC地址）传输以太网数据包的。也就是说IP数据包在局域网内部传输时并不是靠IP地址而是靠MAC地址来识别目标的，因此IP地址与MAC地址之间就必须存在一种对应关系，而ARP协议就是用来确定这种对应关系的协议。<br>ARP是地址解析协议，用于根据目的IP地址来解析MAC地址，进行二层通讯。<br><strong>二、工作原理</strong><br>工作原理是通过广播发送ARP查询请求目的IP的MAC地址，与发送方处于同一广播域的主机收到该请求后，如果确认查询的IP是本机，则单播回应本机的MAC地址；如果发现查询的IP不是本机，则不回应；发送方接收到ARP回应后，把该IP和MAC地址写入本机ARP缓存表，下次再与该IP进行二层通讯，则直接使用表中的记录来进行转发。<br><strong>三、ARP的使用场景</strong><br>1、如果目的IP和本机IP属于同一网段，则ARP请求查询的就是目的IP的MAC地址<br>2、如果目的IP和本机IP不属于同一网段，当本机存在到达目的IP的路由时，则ARP请求查询的就是该路由下一跳的MAC地址；如果没有明细路由，就请求查询缺省路由下一跳（也就是网关）的MAC地址。</p>]]></content>
      
      
      <categories>
          
          <category> 网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 以太网 </tag>
            
            <tag> 局域网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础命令</title>
      <link href="/2021/06/07/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/06/07/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<hr><p>一、基础命令</p><p>​    ls        //列出目录内容</p><p>​                d    //目录文件</p><p>​                b   //块设备文件（block）</p><p>​                c   //字符设备文件（character）</p><p>​                l   //符号链接文件（symbolic link file）                </p><p>​                p   //命令管道（pipe）</p><p>​                s   //套接字文件（socket）</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周乐的第一篇博客</title>
      <link href="/2021/06/05/%E5%91%A8%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/06/05/%E5%91%A8%E4%B9%90%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>北极光</title>
      <link href="/%E5%8C%97%E6%9E%81%E5%85%89/index.html"/>
      <url>/%E5%8C%97%E6%9E%81%E5%85%89/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="/contact/index.html"/>
      <url>/contact/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<p>阿里云镜像站:<a href="https://developer.aliyun.com/special/mirrors/notice">阿里云镜像站</a></p><p>清华大学镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>Strong博客：<a href="https://www.hanzz.red/">Strong-在线文档库</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
